
## Массивы

>Инициализация массивов.

**Инициализация одномерноего массива** <br>
Где `length` - это задаваемая длина создаваемого массива.<br>
А `int`, `string` и так длаее - это типы данных, которые хранит массив. типизация строгая, задаётся сразу при создании и не меняется.
```c#
int[] array = new int[length]; 

string[] array = new string[length];

double[] array = new double[length];
```
**Инициализация двумерного массива.**<br> 
Где `length` - задаваемый рамер массива по вериткали, а `length2` - размер массива по горизонтали (по строке, где будут храниться элементы массива.)
```c#
int[,] array = new int[length, length2]; 
```
**Инициализация одномерного и двумерного массива** с ручным заполнением элементами сразу при создании этих массивов.
Длина массивов будет определена колличество записанных элементов и не может быть изменена после.
```c#
int[] array = {1 ,2, 3}; 
int[,] array = {{1, 2}, {1, 2}}
```
Что бы обратиься к элементу в массиве.<br> 
**В одномерном массиве**, просто указывается индекс нужного элемента в скобках.<br> 
**В двумерном массиве**, сначало индекс строки, а потом индекс элемента в этой строке. Счёт индекса начинается с `0`.
```c#
array[0];
array[0, 0];
```
Быстрый способ **распечатать одномерный массив**, без использования циклов.
```c#
Console.Write(string.Join(" ", array));
```
Что бы **рапечатать двумерный массив** нужен двойной цикл.
Где `GetLength(0)` - получает длину массива(`array`) по колличеству строк, а `GetLength(1)` - получает длину по колличеству элементов в строке. <br>
`i` - задаёт индекс строки, а `j` - уже индекс элементов в этой строке.
```c#
for(int i = 0; i < array.GetLength(0); i++)
{
    for(int j = 0; j < array.GetLength(1); j++)
    {
        Console.Write($"{array[i, j]}");
    }
    Cosole.WriteLine();
}
```
## Random

> Инициализация класса рандом и генерация рандомного числа.


Создаёт отдельный экземпляр(`randomNumb`) класса `Random`, с помощью которого генерируется рандомное натуральное(целое) число, в заданном диапозоне от минимального `min` включительно до `max` не включительно(т.е. при значении max 100, генерация чисел будет до 99.).
```c#
Random randomNumb = new Random(); 
 int num = randomNumb.Next(min, max);
```
Всё тоже самое, но для вещественных(имеющих остаток - числа после запятой(0.432)) чисел.<br> 
Для ограничения колличества чисел после запятой, используется `Math.Round`, округляющий остаток по последенй заданной цифре. В примере это `3`. Т.е. 0.45670001, станет 0.457 <br> 
Умножение  на `100` позволяет сместить запятую в право и добавить рандомному числу  *положительных* целых чисел. т.е сгенерированное число 0.45648573 станет 45.648573. <br>
У `Math.Round` так же есть дополнительные модификаторы. Смотреть раздел с этим классом.
```c#
Random randomDoub = new Random(); 
 double num2 = Math.Round(randomDoub.NextDouble() * 100, 3);
```
Вариант генерации вещественных чисел, с возможностью расширения диапозона до *отрицательных* чисел.
`- 100` - нижняя граница в отрицательном диапазоне. При этом, `200`  всегда должно быть в два раза больше, вычитаемого числа.
В пирмере, диапозон целых чисел идёт от `-100` до `100`.
```c#
Random randomDoub = new Random(); 
 double num2 = Math.Round(randomDoub.NextDouble() * 200 - 100, 3);
```
Упрощённый вариант генерации наруральных(можно сделать и для вещественных по этому же шаблону) чисел, в заданном диапозоне.<br>
Идея в том, что бы обойтись без создания отдельного экземпляра класса.   
```c#
int num4 = new Random().Next(min, max);
```
## Ввод и вывод

> Ввод и поверка введёного значения.

Вводим число, новертируем в инт и проверяем, на то былали строка успешно конвертирована. 
Если не успешно (пользователь ввёл не цифры или не целочисленные значения), то отрабатывает цикл и запрашивает ввод по новой, пока не будет введено корректное значение.
```c#
while (int.TryParse(Console.ReadLine(), out int peremennaR) == false)
     {
         Console.Write("Введена не корректная длина массива. Попробуйте ещё раз: ");
     }
```

Простой способ вывести вещественное число с ограничение вещественной части. (с округлением)<br>
`:f` Способ ограничить колличество знаков после запятой, на выводе в консоль.<br>
Где `2` - это колличество знаков. $ - обязательно для форматирования выводимой Строки. 
```c#
Console.WriteLine($"{b:f2}"); 
```
## Метод Math

> Метод Math.Round с модификатором нулевого округления.

Позволяет отбросить не нужные цифры после запятой, без округления последней цифры .

`test` - обрабатываемое число или переменная с этим числом.

`3` - колличество чимволов после запятой, после которых очставшиеся символы буду отброшены.

`MidpointRounding.ToZero` - модификатор, позволяющий отбрасывать не нужную вещественную часть, без округления по последней цифре.
```C#
Math.Round(test, 3, MidpointRounding.ToZero)
```
> Метод Math.Truncate

Возвращает только целые числа. Т.е. отбрасывает все значения после запятой, без округления.
```c#
double num3 = Math.Truncate(num2); 
```

> Метод Math.Log10

Быстрый способ получить длину числа. Через логорифм.
`num` - число.
```c#
int num = 1246;
int length = (int)Math.Log10(num) + 1; 
```






